<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://leilei666.github.io/my-blog/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/my-blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/my-blog/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/my-blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/my-blog/">Home</a>
        
          <a class="main-nav-link" href="/my-blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/my-blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://leilei666.github.io/my-blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-springboot定时任务执行" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/11/29/springboot定时任务执行/" class="article-date">
  <time datetime="2019-11-29T08:26:16.000Z" itemprop="datePublished">2019-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/11/29/springboot定时任务执行/">springboot定时任务执行</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-定时任务实现的几种方式："><a href="#一-定时任务实现的几种方式：" class="headerlink" title="一.定时任务实现的几种方式："></a>一.定时任务实现的几种方式：</h2><p>1.Timer：这是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。<br>2.ScheduledExecutorService：也jdk自带的一个类；是基于线程池设计的定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。<br>3.Spring Task：Spring3.0以后自带的task，可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多。<br>4.Quartz：这是一个功能比较强大的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来稍显复杂。</p>
<h2 id="二-使用Spring-Task"><a href="#二-使用Spring-Task" class="headerlink" title="二.使用Spring Task"></a>二.使用Spring Task</h2><p>1.创建任务类</p>
<pre><code> 1 @Slf4j
 2 @Component
 3 public class ScheduledService {
 4     @Scheduled(cron = &quot;0/5 * * * * *&quot;)
 5     public void scheduled(){
 6         log.info(&quot;=====&gt;&gt;&gt;&gt;&gt;使用cron  {}&quot;,System.currentTimeMillis());
 7     }
 8     @Scheduled(fixedRate = 5000)
 9     public void scheduled1() {
10         log.info(&quot;=====&gt;&gt;&gt;&gt;&gt;使用fixedRate{}&quot;, System.currentTimeMillis());
11     }
12     @Scheduled(fixedDelay = 5000)
13     public void scheduled2() {
14         log.info(&quot;=====&gt;&gt;&gt;&gt;&gt;fixedDelay{}&quot;,System.currentTimeMillis());
15     }
16 }</code></pre><p>2.在主类上使用@EnableScheduling注解开启对定时任务的支持，然后启动项目创建任务类</p>
<pre><code> 1 import org.springframework.boot.SpringApplication;
 2 import org.springframework.boot.autoconfigure.SpringBootApplication;
 3 import org.springframework.scheduling.annotation.EnableScheduling;
 4 
 5 @SpringBootApplication
 6 @EnableScheduling
 7 public class SpringBootScheduledApplication {
 8 
 9     public static void main(String[] args) {
10         SpringApplication.run(SpringBootScheduledApplication.class, args);
11     }</code></pre><p>3.多线程执行</p>
<p>在传统的Spring项目中，我们可以在xml配置文件添加task的配置，而在SpringBoot项目中一般使用config配置类的方式添加配置，所以新建一个AsyncConfig类</p>
<pre><code> 1 @Configuration
 2 @EnableAsync
 3 public class AsyncConfig {
 4 /*
 5 此处成员变量应该使用@Value从配置中读取
 6 */
 7 private int corePoolSize = 10;
 8 private int maxPoolSize = 200;
 9 private int queueCapacity = 10;
10 @Bean
11 public Executor taskExecutor() {
12 ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
13 executor.setCorePoolSize(corePoolSize);
14 executor.setMaxPoolSize(maxPoolSize);
15 executor.setQueueCapacity(queueCapacity);
16 executor.initialize();
17 return executor;
18 }
19 }</code></pre><p>@Configuration：表明该类是一个配置类 </p>
<p>@EnableAsync：开启异步事件的支持</p>
<p>然后在定时任务的类或者方法上添加@Async 。最后重启项目，每一个任务都是在不同的线程中</p>
<p>4.执行时间的配置</p>
<p>在上面的定时任务中，我们在方法上使用@Scheduled注解来设置任务的执行时间，并且使用三种属性配置方式：</p>
<pre><code>fixedRate：定义一个按一定频率执行的定时任务
fixedDelay：定义一个按一定频率执行的定时任务，与上面不同的是，改属性可以配合initialDelay， 定义该任务延迟执行时间。
cron：通过表达式来配置任务执行时间</code></pre><p>5.cron表达式详解</p>
<p>一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素。按顺序依次为：</p>
<pre><code>秒（0~59）
分钟（0~59）
3 小时（0~23）
4 天（0~31）
5 月（0~11）
6 星期（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）
年份（1970－2099）</code></pre><p>其中每个元素可以是一个值(如6),一个连续区间(9-12),一个间隔时间(8-18/4)(/表示每隔4小时),一个列表(1,3,5),通配符。由于”月份中的日期”和”星期中的日期”这两个元素互斥的,必须要对其中一个设置。配置实例：</p>
<pre><code>每隔5秒执行一次：/5 * ?
每隔1分钟执行一次：0 /1 ?
0 0 10,14,16 ? 每天上午10点，下午2点，4点
0 0/30 9-17 ? 朝九晚五工作时间内每半小时
0 0 12 ? * WED 表示每个星期三中午12点
“0 0 12 ?” 每天中午12点触发
“0 15 10 ? “ 每天上午10:15触发
“0 15 10 ?” 每天上午10:15触发
“0 15 10 ? *” 每天上午10:15触发
“0 15 10 ? 2005” 2005年的每天上午10:15触发
“0 14 * ?” 在每天下午2点到下午2:59期间的每1分钟触发
“0 0/5 14 ?” 在每天下午2点到下午2:55期间的每5分钟触发
“0 0/5 14,18 ?” 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发
“0 0-5 14 ?” 在每天下午2点到下午2:05期间的每1分钟触发
“0 10,44 14 ? 3 WED” 每年三月的星期三的下午2:10和2:44触发
“0 15 10 ? * MON-FRI” 周一至周五的上午10:15触发
“0 15 10 15 * ?” 每月15日上午10:15触发
“0 15 10 L * ?” 每月最后一日的上午10:15触发
“0 15 10 ? * 6L” 每月的最后一个星期五上午10:15触发
“0 15 10 ? * 6L 2002-2005” 2002年至2005年的每月的最后一个星期五上午10:15触发
“0 15 10 ? * 6#3” 每月的第三个星期五上午10:15触发</code></pre><h2 id="三-整合Quartz"><a href="#三-整合Quartz" class="headerlink" title="三.整合Quartz"></a>三.整合Quartz</h2><p>1.添加依赖<br>如果SpringBoot版本是2.0.0以后的，则在spring-boot-starter中已经包含了quart的依赖，则可以直接使用spring-boot-starter-quartz依赖：</p>
<pre><code>1 &lt;dependency&gt;
2     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
3     &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;
4 &lt;/dependency&gt;</code></pre><p>如果是1.5.9则要使用以下添加依赖：</p>
<pre><code>1 &lt;dependency&gt;
2   &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;
3   &lt;artifactId&gt;quartz&lt;/artifactId&gt;
4   &lt;version&gt;2.3.0&lt;/version&gt;
5 &lt;/dependency&gt;
6 &lt;dependency&gt;
7   &lt;groupId&gt;org.springframework&lt;/groupId&gt;
8   &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;
9 &lt;/dependency&gt;</code></pre><p>2.创建任务类TestQuartz，该类主要是继承了QuartzJobBean</p>
<pre><code> 1 public class TestQuartz extends QuartzJobBean {
 2     /**
 3      * 执行定时任务
 4      * @param jobExecutionContext
 5      * @throws JobExecutionException
 6      */
 7     @Override
 8     protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException {
 9         System.out.println(&quot;quartz task &quot;+new Date());
10     }
11 }</code></pre><p>3.创建配置类QuartzConfig</p>
<pre><code> 1 @Configuration
 2 public class QuartzConfig {
 3     @Bean
 4     public JobDetail teatQuartzDetail(){
 5         return JobBuilder.newJob(TestQuartz.class).withIdentity(&quot;testQuartz&quot;).storeDurably().build();
 6     }
 7 
 8     @Bean
 9     public Trigger testQuartzTrigger(){
10         SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()
11                 .withIntervalInSeconds(10)  //设置时间周期单位秒
12                 .repeatForever();
13         return TriggerBuilder.newTrigger().forJob(teatQuartzDetail())
14                 .withIdentity(&quot;testQuartz&quot;)
15                 .withSchedule(scheduleBuilder)
16                 .build();
17     }
18 }</code></pre><p>4.启动项目</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leilei666.github.io/my-blog/2019/11/29/springboot定时任务执行/" data-id="ck3jwi94g0005z4w12cg1e3dl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Freemarker的基本语法及入门基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/10/18/Freemarker的基本语法及入门基础/" class="article-date">
  <time datetime="2019-10-18T09:14:09.000Z" itemprop="datePublished">2019-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/10/18/Freemarker的基本语法及入门基础/">Freemarker的基本语法及入门基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、freemarker模板文件-ftl-的基本组成部分"><a href="#一、freemarker模板文件-ftl-的基本组成部分" class="headerlink" title="一、freemarker模板文件(*.ftl)的基本组成部分"></a>一、freemarker模板文件(*.ftl)的基本组成部分</h3><ol>
<li>文本：直接输出的内容部分</li>
<li>注释：不会输出的内容，格式为&lt;#–  注释内容  –&gt;</li>
<li>取值(插值)：代替输出数据模型的部分，格式为${数据模型}或#{数据模型}</li>
<li>ftl指令：Freemarker指令，类似于HTML标记。<pre><code>内建指令：开始标签:&lt;#directivename parameter&gt;     
         结束标签:&lt;/#directivename&gt;      
         空标签:&lt;#directivename parameter/&gt;   
自定义指令：开始标签:&lt;@directivename parameter&gt;       
           结束标签:&lt;/@directivename&gt;      
           空标签:&lt;@directivename parameter/&gt;
至于什么是内建指令，什么是自定义指令   我会在下面叙述到。</code></pre></li>
</ol>
<h3 id="二、Freemarker语法及使用方法"><a href="#二、Freemarker语法及使用方法" class="headerlink" title="二、Freemarker语法及使用方法"></a>二、Freemarker语法及使用方法</h3><ol>
<li><p>取值(插值)指令及适用类型：</p>
<pre><code>(1) ${var}
        适用类型：java中常用的八大基本类型以及我们的String引用类型，但是，freemarker中boolean类型显示时true==yes  false==no
        示例：
                在后台文件中定义变量
                        String strVar = &quot;世界你好&quot;;
                        int intVar = 10;
                        boolean booVar = true;
                在页面中获取变量：
                        String获取：&lt;font color=&quot;red&quot;&gt; ${strVar} &lt;/font&gt;&lt;br&gt;
                        int获取：&lt;font color=&quot;red&quot;&gt; ${intVar} &lt;/font&gt;&lt;br&gt;
                        boolean获取：&lt;font color=&quot;red&quot;&gt; ${booVar?string(&quot;yes&quot;,&quot;no&quot;)} &lt;/font&gt;
                展示结果：
                        String获取：世界你好
                        int获取：10
                        boolean获取：yes
(2)${var!}
        适用类型：对 null 或者不存在的对象进行取值，可以设置默认值，例：${var!&apos;我是默认值&apos;}    即，有值时显示正常值，无值时显示默认值
        示例：
                在后台文件中定义变量
                        String strVar = &quot;世界你好&quot;;
                        String str = null;
                在页面中获取变量：
                        String获取：&lt;font color=&quot;red&quot;&gt; ${strVar!&quot;我是空&quot;} &lt;/font&gt;&lt;br&gt;
                        str获取：&lt;font color=&quot;red&quot;&gt; ${str!} &lt;/font&gt;&lt;br&gt;
                        str获取：&lt;font color=&quot;red&quot;&gt; ${str!&quot;默认&quot;} &lt;/font&gt;&lt;br&gt;
                展示结果：
                        String获取：世界你好
                        str获取：
                        str获取：默认
(3)${封装对象.属性}
        适用类型：对封装对象进行取值，例：${User.name}
        示例：
                在后台文件中封装对象User[ name,  age ]
                        String name = &quot;姓名&quot;;
                        int age = 18;
                在页面中获取变量：
                        name获取：&lt;font color=&quot;red&quot;&gt; ${User.name} &lt;/font&gt;&lt;br&gt;
                        age获取：&lt;font color=&quot;red&quot;&gt; ${User.age} &lt;/font&gt;&lt;br&gt;
                展示结果：
                        name获取：姓名
                        age获取：18
(4)${date?String(&apos;yyyy-MM-dd&apos;)}
        适用类型：对日期格式进行取值，在这里我要强调的是，定义Date类型的变量时，java.util.Date无法输出日期，须使用java.sql.Date
        示例：
                在后台文件中定义变量
                        java.sql.Date date = new Date().getTime();
                        java.sql.Date time = new Date().getTime();
                        java.sql.Date datetime = new Date().getTime();
                在页面中获取变量：
                        date获取：&lt;font color=&quot;red&quot;&gt; ${date?string(&apos;yyyy-MM-dd&apos;)} &lt;/font&gt;&lt;br&gt;
                        time获取：&lt;font color=&quot;red&quot;&gt; ${date?string(&apos;HH:mm:ss&apos;)} &lt;/font&gt;&lt;br&gt;
                        datetime获取：&lt;font color=&quot;red&quot;&gt; ${date?string(&apos;yyyy-MM-dd HH:mm:ss&apos;)} &lt;/font&gt;&lt;br&gt;
                展示结果：
                        name获取：姓名
                        age获取：18
(5)${var?html}
        适用类型：转义HTML内容
        示例：
                在后台文件中封装变量Menu[ name, model ]
                        Menu m = new Menu();
                        m.setName(&quot; freemarker &quot;);
                        m.setModel(&quot;&lt;font color = &apos;red&apos;&gt;我只是个菜单&lt;/font&gt;&quot;);
                在页面中获取变量：
                        非转义获取：&lt;font color=&quot;red&quot;&gt; ${m.model} &lt;/font&gt;&lt;br&gt;
                        转义获取： ${m.model?html} &lt;/font&gt;&lt;br&gt;
                展示结果：
                        非转义获取：我只是个菜单
                        转义获取：&lt;font color = &apos;red&apos;&gt;我只是个菜单&lt;/font&gt;
(6)&lt;#assign num = 100 /&gt;
        适用类型：定义变量，支持计算和赋值
        示例：
                在页面中定义变量：
                        &lt;#assign num = 100 /&gt;
                        num获取：&lt;font color=&quot;red&quot;&gt; ${num)} &lt;/font&gt;&lt;br&gt;
                        计算结果：&lt;font color=&quot;red&quot;&gt; ${num * 10} &lt;/font&gt;&lt;br&gt;
                展示结果：
                        num获取：100
                        计算结果：1000
(7)对List集合进行取值
        &lt;#list  list集合  as  item&gt;
               ${item}    --取值
        &lt;/#list&gt;
        示例：
                在后台文件中定义变量
                        List&lt;String&gt; strList = new ArrayList&lt;String&gt;();
                        strList.add(&quot;第一个值&quot;);
                        strList.add(&quot;第二个值&quot;);
                        strList.add(&quot;第三个值&quot;);
                在页面中获取变量：
                        &lt;#list  strList  as  item&gt;
                               ${item!}&lt;br/&gt;    --取值
                        &lt;/#list&gt;
                展示结果：
                        第一个值
                        第二个值
                        第三个值
(8)对Map集合进行取值
        &lt;#list map?keys as key&gt;
               ${key}:${map[key]}
        &lt;/#list&gt;
        示例：
                在后台文件中定义变量
                        Map&lt;String, Object&gt; m = new HashMap&lt;String, Object&gt;();
                        m.put(&quot;name&quot;,&quot;姓名&quot;);
                        m.put(&quot;age&quot;,18);
                        m.put(&quot;sex&quot;,&quot;男&quot;);
                在页面中获取变量：
                         &lt;#list m?keys as key&gt;
                                ${key}:${m[key]}
                         &lt;/#list&gt;
                展示结果：
                        name：姓名
                        age：18
                        sex：男</code></pre></li>
<li><p>条件判断指令：</p>
<pre><code>(1) if
        格式：&lt;#if 条件&gt;
                        输出
                     &lt;/#if&gt;
        示例：
                在页面中定义变量并判断条件：
                        &lt;#assign age = 18 /&gt;&lt;br&gt;
                        &lt;#if age == 18&gt;
                                &lt;font color=&quot;red&quot;&gt; age = 18&lt;/font&gt;
                        &lt;/#if&gt;
                展示结果：
                        age = 18
(2) if - else
        格式：&lt;#if 条件&gt;
                        输出
                    &lt;#else&gt;
                        输出
                    &lt;/#if&gt;
        示例：
                在页面中定义变量并判断条件：
                        &lt;#assign age = 20 /&gt;&lt;br&gt;
                        &lt;#if age == 18&gt;
                                &lt;font color=&quot;red&quot;&gt; age = 18&lt;/font&gt;
                        &lt;#else&gt;
                                &lt;font color=&quot;red&quot;&gt; age != 18&lt;/font&gt;
                        &lt;/#if&gt;
                展示结果：
                        age != 18
(3) if - elseif - else
        格式：&lt;#if 条件1&gt;
                        输出
                    &lt;#elseif 条件2&gt;
                        输出
                    &lt;#else&gt;
                        输出
                    &lt;/#if&gt;
        示例：
                在页面中定义变量并判断条件：
                        &lt;#assign age = 20 /&gt;&lt;br&gt;
                        &lt;#if age &amp;gt; 18&gt;
                                &lt;font color=&quot;red&quot;&gt;青年&lt;/font&gt;
                        &lt;#elseif age == 18&gt;
                                &lt;font color=&quot;red&quot;&gt; 成年&lt;/font&gt;
                        &lt;#else&gt;
                                &lt;font color=&quot;red&quot;&gt; 少年&lt;/font&gt;
                        &lt;/#if&gt;
                展示结果：
                        成年
(4) switch  --常与case break default一起使用  参数可为字符串
        格式：&lt;#switch var&gt;
                    &lt;#case 条件1&gt;
                          输出
                    &lt;#break&gt;
                    &lt;#case 条件2&gt;
                          输出
                    &lt;#break&gt;
                    &lt;#default&gt;
                          输出
                    &lt;/#switch&gt;
        示例：
                在页面中定义变量并判断：
                       &lt;#switch var=&quot;星期一&quot;&gt;
                       &lt;#case &quot;星期一&quot;&gt;
                               油焖大虾
                       &lt;#break&gt;
                       &lt;#case &quot;星期二&quot;&gt;
                               炸酱面
                       &lt;#break&gt;
                       &lt;#default&gt;
                               肯德基
                       &lt;/#switch&gt;
                展示结果：
                        油焖大虾</code></pre></li>
<li><p>自定义函数、自定义指令：</p>
<pre><code>(1) 自定义函数
        实现TemplateMthodModelEx
(2) 自定义指令
        实现TemplateDirectiveModel
        示例：
                &lt;@自定义指令名称 入参(key-value格式) ; 出参(list格式)&gt;
                        运行条件
                &lt;/@自定义指令名称&gt;

                PS:不同的返回值用逗号( , )间隔开</code></pre></li>
</ol>
<p>4.常用内建函数、macro(宏指令)、function(函数指令)：</p>
<pre><code>(1) 常用内建函数
        处理字符串：
             substring                                          截取字符串，包头不包尾（下标）
             cap_first                                          第一个字母大写
             end_with                                           以什么字母结尾    
             contains                                            是否包含目标字符串
             date  datetime  time                       转换成日期格式
             starts_with                                      以什么字母开头
             index_of                                          返回某个指定的字符串值在字符串中首次出现的位置（下标）
             last_index_of                                  获取指定字符出现的最后位置（下标）
             split                                                  分隔
             trim                                                  去两端空格
        处理数字：
             string                                              
             x?string(&quot;0.##&quot;)                          变成小数点后几位
             round                                              四舍五入
             floor                                               去掉小数点
             ceiling                                             近1   变成整数
        处理list:
              first:                                              取List值第一个值
              last:                                                取List值最后一个值
              seq_contains:                                是否包含指定字符
              seq_index_of:                               指定字符所在位置
              size:                                                集合大小
               reverse:                                          集合倒序排列
              sort:                                                对集合进行排序
              sort_by:                                         根据某一个属性排序
              chunk:                                            分块处理
        其他:
              is_string:                                      是否为字符类型
              is_number:                                    是否为整数类型
              is_method:                                   是否为方法
              ():                                                  判断整个变量
              has_content:                                判断对象是否为空或不存在
              eval：                                           求值
(2) macro(宏指令)
        调用：&lt;@macro_name param /&gt;
        语法：&lt;#macro  变量名  参数&gt;  
                            &lt;#nested/&gt;  
                    &lt;/#macro&gt;
(3) function(函数指令)
        调用：${function_name(param)}
        语法：&lt;#function  变量名  参数&gt;  
                    &lt;#return&gt;  
                    &lt;/#function&gt;</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://leilei666.github.io/my-blog/2019/10/18/Freemarker的基本语法及入门基础/" data-id="ck3jwi95c000cz4w1nxuzh08h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java原子类及内部原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/10/12/java原子类及内部原理/" class="article-date">
  <time datetime="2019-10-12T08:46:43.000Z" itemprop="datePublished">2019-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/10/12/java原子类及内部原理/">java原子类及内部原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h3><p>原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。再比如：a++；</p>
<p>这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一</p>
<p>个原子操作。</p>
<p>但是，像i++这种非原子操作，我们除了使用synchroinzed关键字实现同步外，还可以使用java.util.concurrent.atomic提供的线程安全的原子类来实现，例如</p>
<p>AtomicInteger、AtomicLong、AtomicReference等。下面我们就基于AtomicInteger为例，来看看其内部实现。</p>
<h3 id="二、AtomicInteger的内部实现"><a href="#二、AtomicInteger的内部实现" class="headerlink" title="二、AtomicInteger的内部实现"></a>二、AtomicInteger的内部实现</h3><p>public class AtomicInteger extends Number implements java.io.Serializable {<br>    private static final long serialVersionUID = 6214790243416807050L;</p>
<pre><code>// setup to use Unsafe.compareAndSwapInt for updates
private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;

static {
    try {
        valueOffset = unsafe.objectFieldOffset
            (AtomicInteger.class.getDeclaredField(&quot;value&quot;));
    } catch (Exception ex) { throw new Error(ex); }
}

private volatile int value;</code></pre><p>这段代码我们需要注意一下几个方面：</p>
<p>（1）unsafe字段，AtomicInteger包含了一个Unsafe类的实例，unsafe就是用来实现CAS机制的，CAS机制我们在后面会讲到；</p>
<p>（2）value字段，表示当前对象代码的基本类型的值，AtomicInteger是int型的线程安全包装类，value就代码了AtomicInteger的值。注意，这个字段是volatile的。</p>
<p>（3）valueOfset，指是value在内存中的偏移量，也就是在内存中的地址，通过Unsafe.objectFieldOffset(Field f)获取。这个值在使用CAS机制的时候会用到。</p>
<p>下面我们来看一个AtomicInteger类中的主要方法getAndIncrement()，也就相当于i++操作，只不过它是线程安全的，其实现代码如下：</p>
<pre><code>public final int getAndIncrement() {
         for (;;) {
             int current = get();
             int next = current + 1;
             if (compareAndSet(current, next))
                 return current;
         }
 }
   这个方法的做法为先获取到当前的 value 属性值，然后将 value 加 1，赋值给一个局部的 next 变量，然而，这两步都是非线程安全的，但是内部有一个死循环，</code></pre><p>不断去做compareAndSet操作，直到成功为止，也就是修改的根本在compareAndSet方法里面。compareAndSet()方法的代码如下：</p>
<p>public final boolean compareAndSet(int expect, int update) {<br>        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);<br> }<br>      compareAndSet 传入的为执行方法时获取到的 value 属性值，update为加 1 后的值， compareAndSet所做的为调用 Sun 的 UnSafe 的 compareAndSwapInt</p>
<p>方法来完成，此方法为 native 方法，compareAndSwapInt 基于的是CPU 的 CAS指令来实现的。下面我们将详细的来介绍一下CAS的实现原理。</p>
<h3 id="三、CAS机制"><a href="#三、CAS机制" class="headerlink" title="三、CAS机制"></a>三、CAS机制</h3><p>CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。CAS机制当中使用了3个基本操作数：</p>
<p>（1）内存地址V，也就是AtomicInteger中的valueOffset。</p>
<p>（2）旧的预期值A，也就是getAndIncrement方法中的current。</p>
<p>（3）要修改的新值B，也就是getAndIncrement方法中的next。</p>
<p>CAS机制中，更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。下面我们来看一个具体的例子：</p>
<p>（1）在内存地址V当中，存储着值为10的变量。</p>
<p>（2）此时线程1想要把变量的值增加1。对线程1来说，旧的预期值A=10，要修改的新值B=11。</p>
<p>（3）但是，在线程1要提交更新之前，另一个线程2抢先一步，把内存地址V中的变量值率先更新成了11。</p>
<p>（4）此时，线程1开始提交更新，首先进行A和地址V的实际值比较（Compare），发现A不等于V的实际值，提交失败。</p>
<p>（5）线程1重新获取内存地址V的当前值，并重新计算想要修改的新值。此时对线程1来说，A=11，B=12。这个重新尝试的过程被称为自旋。</p>
<p>（6）这一次比较幸运，没有其他线程改变地址V的值。线程1进行Compare，发现A和地址V的实际值是相等的。</p>
<p>（7）线程1进行替换，把地址V的值替换为B，也就是12。</p>
<p>对比Synchronized，我们可以发现，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么</p>
<p>严重，所以让线程不断去尝试更新。</p>
<p>但是CAS机制通常也存在以下缺点：</p>
<p>（1）ABA问题</p>
<p>   如果V的初始值是A，在准备赋值的时候检查到它仍然是A，那么能说它没有改变过吗？也许V经历了这样一个过程：它先变成了B，又变成了A，使用CAS检查时</p>
<p>以为它没变，其实却已经改变过了。</p>
<p>（2）CPU开销较大</p>
<p> 在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p>
<p>（3）不能保证代码块的原子性</p>
<p> CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leilei666.github.io/my-blog/2019/10/12/java原子类及内部原理/" data-id="ck3jwi94a0003z4w1xps5lk8r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/09/27/git命令/" class="article-date">
  <time datetime="2019-09-27T06:36:33.000Z" itemprop="datePublished">2019-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/09/27/git命令/">git命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>git init    初始化</p>
<p>git status  查看仓库当前的状态</p>
<p>git diff <file>  查看具体修改了什么内容</file></p>
<p>git diff HEAD –<file> 命令可以查看工作区和版本库里面最新版本的区别</file></p>
<p>git add <file> 添加到暂存</file></p>
<p>git add -f <file>  假如文件被忽略这样可以强制添加</file></p>
<p>git commit -m “balabalabala” 提交暂存区的文件到本地仓库</p>
<p>git log –graph –pretty=oneline 查看日志</p>
<p>git reset –hard HEAD^   (git reset –hard 版本编号)  版本回退 </p>
<p>git reset HEAD <file> 添加到了暂存区时，想丢弃修改 </file></p>
<p>git checkout –<file>  当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时</file></p>
<p>git rm <file> 从版本库中删除该文件(然后commit)</file></p>
<p>git remote   查看远程库信息</p>
<p>git remote -v  更加详细的查看</p>
<p>git remote add origin 地址  本地关联远程库</p>
<p>git clone  地址   克隆远程库</p>
<p>git branch  查看当前分支 </p>
<p>git branch <name>   创建分支</name></p>
<p>git checkout <name>   切换分支</name></p>
<p>git checkout -b <name>  我们创建分支，然后切换到分支</name></p>
<p>git merge <name>  合并分支到当前分支</name></p>
<p>git merge –no-ff -m “xxxxx” <name>   合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并</name></p>
<p>git branch -d <name>   删除分支</name></p>
<p>git branch -D <name>   强行删除</name></p>
<p>git pull origin <name>   拉取</name></p>
<p>git push origin <name>  推送</name></p>
<p>git stash    把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p>
<p>git stash list   查看贮藏区</p>
<p>git stash apply  恢复后，stash内容并不删除</p>
<p>git stash drop    删除贮藏区的内容</p>
<p>git stash pop     恢复的同时把stash内容也删了</p>
<p>你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令 git stash apply stash@{0}</p>
<p>git rebase  变基(线路变得好看)</p>
<p>git tag <tagname>   打标签</tagname></p>
<p>git tag -a <tagname> -m “balabalbal…”   可以指定标签信息</tagname></p>
<p>git tag   查看所有标签</p>
<p>git show <tagname>   查看该标签版本信息</tagname></p>
<p>git tag -d <tagname>  删除标签</tagname></p>
<p>git push origin <tagname>  推送标签到远程</tagname></p>
<p>git push origin –tags   一次性推送全部尚未推送到远程的本地标签</p>
<p>git push origin :refs/tags/<tagname>  可以删除一个远程标签</tagname></p>
<p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>git reflog用来记录你的每一次命令(强力后悔药!!!!!!!!!!)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leilei666.github.io/my-blog/2019/09/27/git命令/" data-id="ck3jwi9470002z4w1f5f7t95m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java开发必会的linux命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/09/20/java开发必会的linux命令/" class="article-date">
  <time datetime="2019-09-20T07:27:46.000Z" itemprop="datePublished">2019-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/09/20/java开发必会的linux命令/">java开发必会的linux命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-查找文件"><a href="#1-查找文件" class="headerlink" title="1.查找文件"></a>1.查找文件</h3><pre><code>find / -name filename.txt 根据名称查找/目录下的filename.txt文件。

find . -name &quot;*.xml&quot; 递归查找所有的xml文件

find . -name &quot;*.xml&quot; |xargs grep &quot;hello world&quot; 递归查找所有文件内容中包含hello world的xml文件

grep -H &apos;spring&apos; *.xml 查找所以有的包含spring的xml文件

find ./ -size 0 | xargs rm -f &amp; 删除文件大小为零的文件

ls -l | grep &apos;.jar&apos; 查找当前目录中的所有jar文件

grep &apos;test&apos; d* 显示所有以d开头的文件中包含test的行。

grep &apos;test&apos; aa bb cc 显示在aa，bb，cc文件中匹配test的行。

grep &apos;[a-z]\{5\}&apos; aa 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</code></pre><h3 id="2-查看一个程序是否运行"><a href="#2-查看一个程序是否运行" class="headerlink" title="2.查看一个程序是否运行"></a>2.查看一个程序是否运行</h3><pre><code>ps –ef|grep tomcat 查看所有有关tomcat的进程

ps -ef|grep --color java 高亮要查询的关键字</code></pre><h3 id="3-终止线程"><a href="#3-终止线程" class="headerlink" title="3.终止线程"></a>3.终止线程</h3><pre><code>kill -9 19979 终止线程号位19979的进程</code></pre><h3 id="4-查看文件，包含隐藏文件"><a href="#4-查看文件，包含隐藏文件" class="headerlink" title="4.查看文件，包含隐藏文件"></a>4.查看文件，包含隐藏文件</h3><pre><code>ls -al</code></pre><h3 id="5-当前工作目录"><a href="#5-当前工作目录" class="headerlink" title="5.当前工作目录"></a>5.当前工作目录</h3><pre><code>pwd</code></pre><h3 id="6-复制文件"><a href="#6-复制文件" class="headerlink" title="6.复制文件"></a>6.复制文件</h3><pre><code>cp source dest 复制文件

cp -r sourceFolder targetFolder 递归复制整个文件夹

scp sourecFile romoteUserName@remoteIp:remoteAddr 远程拷贝</code></pre><h3 id="7-创建目录"><a href="#7-创建目录" class="headerlink" title="7.创建目录"></a>7.创建目录</h3><pre><code>mkdir newfolder</code></pre><h3 id="8-删除目录"><a href="#8-删除目录" class="headerlink" title="8.删除目录"></a>8.删除目录</h3><pre><code>rmdir deleteEmptyFolder 删除空目录 rm -rf deleteFile 递归删除目录中所有内容</code></pre><h3 id="9-移动文件"><a href="#9-移动文件" class="headerlink" title="9.移动文件"></a>9.移动文件</h3><pre><code>mv /temp/movefile /targetFolder</code></pre><h3 id="10-重命令"><a href="#10-重命令" class="headerlink" title="10.重命令"></a>10.重命令</h3><pre><code>mv oldNameFile newNameFile</code></pre><h3 id="11-切换用户"><a href="#11-切换用户" class="headerlink" title="11.切换用户"></a>11.切换用户</h3><pre><code>su -username</code></pre><h3 id="12-修改文件权限"><a href="#12-修改文件权限" class="headerlink" title="12.修改文件权限"></a>12.修改文件权限</h3><pre><code>chmod 777 file.java //file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行</code></pre><h3 id="13-压缩文件"><a href="#13-压缩文件" class="headerlink" title="13.压缩文件"></a>13.压缩文件</h3><pre><code>tar -czf test.tar.gz /test1 /test2</code></pre><h3 id="14-列出压缩文件列表"><a href="#14-列出压缩文件列表" class="headerlink" title="14.列出压缩文件列表"></a>14.列出压缩文件列表</h3><pre><code>tar -tzf test.tar.gz</code></pre><h3 id="15-解压文件"><a href="#15-解压文件" class="headerlink" title="15.解压文件"></a>15.解压文件</h3><pre><code>tar -xvzf test.tar.gz</code></pre><h3 id="16-查看文件头10行"><a href="#16-查看文件头10行" class="headerlink" title="16.查看文件头10行"></a>16.查看文件头10行</h3><pre><code>head -n 10 example.txt</code></pre><h3 id="17-查看文件尾10行"><a href="#17-查看文件尾10行" class="headerlink" title="17.查看文件尾10行"></a>17.查看文件尾10行</h3><pre><code>tail -n 10 example.txt</code></pre><h3 id="18-查看日志类型文件"><a href="#18-查看日志类型文件" class="headerlink" title="18.查看日志类型文件"></a>18.查看日志类型文件</h3><pre><code>tail -f exmaple.log //这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。</code></pre><h3 id="19-使用超级管理员身份执行命令"><a href="#19-使用超级管理员身份执行命令" class="headerlink" title="19.使用超级管理员身份执行命令"></a>19.使用超级管理员身份执行命令</h3><pre><code>sudo rm a.txt 使用管理员身份删除文件</code></pre><h3 id="20-查看端口占用情况"><a href="#20-查看端口占用情况" class="headerlink" title="20.查看端口占用情况"></a>20.查看端口占用情况</h3><pre><code>netstat -tln | grep 8080 查看端口8080的使用情况</code></pre><h3 id="21-查看端口属于哪个程序"><a href="#21-查看端口属于哪个程序" class="headerlink" title="21.查看端口属于哪个程序"></a>21.查看端口属于哪个程序</h3><pre><code>lsof -i :8080</code></pre><h3 id="22-查看进程"><a href="#22-查看进程" class="headerlink" title="22.查看进程"></a>22.查看进程</h3><pre><code>ps aux|grep java 查看java进程

ps aux 查看所有进程</code></pre><h3 id="23-以树状图列出目录的内容"><a href="#23-以树状图列出目录的内容" class="headerlink" title="23.以树状图列出目录的内容"></a>23.以树状图列出目录的内容</h3><pre><code>tree a

ps:Mac下使用tree命令</code></pre><h3 id="24-文件下载"><a href="#24-文件下载" class="headerlink" title="24. 文件下载"></a>24. 文件下载</h3><pre><code>wget http://file.tgz mac下安装wget命令

curl http://file.tgz</code></pre><h3 id="25-网络检测"><a href="#25-网络检测" class="headerlink" title="25. 网络检测"></a>25. 网络检测</h3><pre><code>ping www.just-ping.com</code></pre><h3 id="26-远程登录"><a href="#26-远程登录" class="headerlink" title="26.远程登录"></a>26.远程登录</h3><pre><code>ssh userName@ip</code></pre><h3 id="27-打印信息"><a href="#27-打印信息" class="headerlink" title="27.打印信息"></a>27.打印信息</h3><pre><code>echo $JAVA_HOME 打印java home环境变量的值</code></pre><h3 id="28-java-常用命令"><a href="#28-java-常用命令" class="headerlink" title="28.java 常用命令"></a>28.java 常用命令</h3><pre><code>java javac jps ,jstat ,jmap, jstack</code></pre><h3 id="29-其他命令"><a href="#29-其他命令" class="headerlink" title="29.其他命令"></a>29.其他命令</h3><pre><code>svn git maven</code></pre><h3 id="28-linux命令学习网站"><a href="#28-linux命令学习网站" class="headerlink" title="28.linux命令学习网站:"></a>28.linux命令学习网站:</h3><pre><code>http://explainshell.com/</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://leilei666.github.io/my-blog/2019/09/20/java开发必会的linux命令/" data-id="ck3jwi94c0004z4w1p9rlz68c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="java-java 10的类型推导" class="article article-type-java" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/09/14/java 10的类型推导/" class="article-date">
  <time datetime="2019-09-14T14:45:53.000Z" itemprop="datePublished">2019-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/09/14/java 10的类型推导/">java 10的类型推导</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java 10带来了全新的语言特性：局部变量类型推导（local variable type inference）。它的主要目标就是减少样板代码（boilerplate），增强代码可读性。可以使用关键词var来替代局部变量的类型声明——编译器会根据变量初始化语句来自己填充正确的类型的。比如说：</p>
<pre><code>Map&lt;User, List&lt;String&gt;&gt; userChannels = new HashMap&lt;&gt;();</code></pre><p>在Java 10中可以这么写：</p>
<pre><code>var userChannels = new HashMap&lt;User, List&lt;String&gt;&gt;();</code></pre><p>除了代码的简洁性，类型推导还有不少优点，本文我们将会一一看下。先来看一个稍微复杂点的例子：</p>
<pre><code>Path path = Paths.get(&quot;src/web.log&quot;);
try (Stream&lt;String&amp;gt; lines = Files.lines(path)){
    long warningCount =
        lines.filter(line -&amp;gt; line.contains(&quot;WARNING&quot;))
             .count();
    System.out.println(
        &quot;Found &quot; + warningCount + &quot; warnings in the log file&quot;);
} catch (IOException e) {
    e.printStackTrace();
}</code></pre><p>在Java 10中可以重构为：</p>
<pre><code>var path = Paths.get(&quot;src/web.log&quot;);
try (var lines = Files.lines(path)){
    var warningCount =
        lines.filter(line -&amp;gt; line.contains(&quot;WARNING&quot;))
             .count();
    System.out.println(
        &quot;Found &quot; + warningCount + &quot; warnings in the log file&quot;);
} catch (IOException e) {
    e.printStackTrace();
}</code></pre><p>代码中的表达式都仍是静态类型的（也就是值所声明的类型），对应如下：</p>
<p>局部变量path类型为Path。<br>变量lines的类型是Stream。<br>warningCount类型是long<br>也就说其它类型的值赋值过去是会报错的。比方说下面重新赋值的代码在编译时就会报错：</p>
<pre><code>var warningCount = 5;
warningCount = &quot;6&quot;;
|  Error:
|  incompatible types: java.lang.String cannot be converted to int
|  warningCount = &quot;6&quot;</code></pre><p>关于类型推导还有一些地方是要注意的。比如说，如果Car和Bike是Vehicle的子类，那么var v = new Car();声明的类型是Car还是Vehicle？</p>
<p>简单来说，省略的类型和初始化的类型是一致的（在这里是Car类型），这点很清楚了，换句话说如果没有初始化语句是不能使用var的。</p>
<p>如果后面再进行v = new Bike();赋值是不行的。换句话说，var是不支持多态的。</p>
<p>什么情况用不了类型推导<br>哪些情况用不了类型推导？首先，只有局部变量可以使用。字段或者方法签名都不支持的。比如说下面这个就是错误的：</p>
<p>public long process(var list) { } 如果没有显式的初始化语句的局部变量声明也是不行的。也就是说不能只用var声明变量却没有赋值。</p>
<p>下面的：</p>
<p>var x; 会返回编译报错：</p>
<pre><code>|  Error:
|  cannot infer type for local variable x
|    (cannot use &apos;var&apos; on variable without initializer)
|  var x;
|  ^----^</code></pre><p>也不能将var变量初始化为null。因为它可能要在后边才进行初始化，这样就无法确定具体类型。</p>
<pre><code>|  Error:
|  cannot infer type for local variable x
|    (variable initializer is &apos;null&apos;)
|  var x = null;
|  ^-----------^</code></pre><p>var也不能用于lambda表达式，因为它需要显式的目标类型。下面的赋值语句会报错：</p>
<p>var x = () -&gt; {} 报这个错误：</p>
<pre><code>|  Error:
|  cannot infer type for local variable x
|    (lambda expression needs an explicit target-type)
|  var x = () -&amp;gt; {};
|  ^---------------^</code></pre><p>不过不一样的是下面的赋值是能通过的，因为右边有显式的初始化语句：</p>
<p>var list = new ArrayList&lt;&gt;(); 但list的静态类型是什么？推导出来的变量类型是ArrayList&lt; Object &gt;，这可能并不是太有意义，因为泛型信息丢失了。所以你可能并不希望这样来赋值。</p>
<p>匿名类型（Nondenotable Types）的推导<br>Java中存在几种匿名类型——这个类型确实存在于程序中，但无法写出它的类型名。匿名类就是一个很好的例子——你可以往它里面添加字段和方法，但无法在代码中引用这个类的名字。&lt;&gt;操作符也无法用于匿名类。var的限制相对少一点，可以支持部分匿名类型——具体来说就是匿名类和交集类型（intersection type）。</p>
<p>var关键词可以更高效地使用匿名类，或用来引用“无法描述清楚”的类型。正常来说，如果你创建了一个匿名类，可以往里面添加新的字段，但却没办法引用这些字段，因为这个对象总会要赋值给一个已知的类型的。</p>
<p>比如说，下面这段代码就没法通过编译，因为productInfo的类型是Object，不可能去访问一个Object对象的name和total字段：</p>
<pre><code>Object productInfo = new Object() {
    String name = &quot;Apple&quot;;
    int total = 30;
};
System.out.println(
    &quot;name = &quot; + productInfo.name + &quot;, total = &quot; + productInfo.total);</code></pre><p>而var能解决这一问题。当你把一个匿名对象赋值给var类型的局部变量时，编译器能推导出匿名类的真正类型，而不只是父类类型。这样你就可以引用匿名类内部所声明的字段了，如下所示：</p>
<pre><code>var productInfo = new Object() {
    String name = &quot;Apple&quot;;
    int total = 30;

};
System.out.println(
    &quot;name = &quot; + productInfo.name + &quot;, total = &quot; + productInfo.total);</code></pre><p>这一功能看起来貌似只是一个很有意思的小的语言特性而已，没什么大用，但在某些场景下还是很有帮助的。比方说，在某个方法里你希望返回几个值作为中间变量。正常来说，只为了在这一个方法里面使用，你就得创建和维护一个新的类型。比如在Collectors.averagingDouble()的实现中，一个小的double数组就是用作这个目的的。</p>
<p>var有一个更好的解决方案：使用匿名类来存储中间值。</p>
<p>再来看一个例子，你有一些产品，产品会有自己的名字，数量，单价。你需要计算每个物品的总价值——也就是数量乘以单价。如果只需要这个信息的话将产品map到它的价值就可以了，但结果信息中可能还需要加上产品名才更有意义。</p>
<p>我们来看下Java 10中通过var可以怎么做：</p>
<pre><code>var products = List.of(
    new Product(10, 3, &quot;Apple&quot;),
    new Product( 5, 2, &quot;Banana&quot;),
    new Product(17, 5, &quot;Pear&quot;));
var productInfos = products
    .stream()
    .map(product -&amp;gt; new Object() {
        String name = product.getName();
        int total = product.getStock() * product.getValue();
}).collect(toList());

productInfos.forEach(prod -&amp;gt; System.out.println(
    &quot;name = &quot; + prod.name + &quot;, total = &quot; + prod.total));</code></pre><p>会输出如下信息：</p>
<pre><code>name = Apple, total = 30
name = Banana, total = 10
name = Pear, total = 85</code></pre><p>并不是所有的匿名类型都能使用var。它只支持匿名类和交集类型。而通配符类型则不支持推导，这是为了避免给Java开发人员展示太多与通配符相关的复杂报错信息。支持匿名类型是为了能尽可能多地保留推导类型的信息，以便能用局部变量来重构更多代码。这项特性最初的设计目标并不是为了编写类似上面这样的代码的，而是希望解决var在处理匿名类型时会碰到的问题。var在匿名类型上的使用是否会流行起来还不好说。</p>
<p>推荐用法<br>类型推导当然可以减少Java代码的编写时间，不过它对可读性有没有提升？开发人员通常花在读代码上的时间比写代码要多得多，因此肯定希望阅读代码时能更轻松一点。而var对可读性的提升是因人而异的：有人喜欢它，有人讨厌它。你应该时刻关注如何能让团队成员能更好地阅读你的代码。如果大家都喜欢var，就用它；否则就不要使用。</p>
<p>有的时候显式类型声明会妨碍可读性。比如说，当遍历Map的entrySet时，需要在Map.Entry中再重复参数类型。下面这段代码会遍历国家下面的各个城市：</p>
<pre><code>Map&lt;String, List&lt;String&amp;gt;&amp;gt; countryToCity = new HashMap&lt;&amp;gt;();
// ...
for (Map.Entry&lt;String, List&lt;String&amp;gt;&amp;gt; citiesInCountry :
    countryToCity.entrySet()) {
        List&lt;String&amp;gt; cities = citiesInCountry.getValue();
// ...
}</code></pre><p>可以用var来重写这段代码，减少重复和样板代码，如下：</p>
<pre><code>var countryToCity = new HashMap&lt;String, List&lt;String&amp;gt;&amp;gt;();
// ...
for (var citiesInCountry : countryToCity.entrySet()) {
    var cities = citiesInCountry.getValue();
// ...
}</code></pre><p>这不光提升了可读性，对代码的可维护性也有提高。</p>
<p>比如说，如果还是同样的代码，如果要将城市从String类型替换为City，增加些额外的城市信息，正常你需要重写代码，因为它依赖了特定的类型。</p>
<pre><code>Map&lt;String, List&lt;City&amp;gt;&amp;gt; countryToCity = new HashMap&lt;&amp;gt;();
// ...
for (Map.Entry&lt;String, List&lt;City&amp;gt;&amp;gt; citiesInCountry :
    countryToCity.entrySet()) {
            List&lt;City&amp;gt; cities = citiesInCountry.getValue();
// ...
}</code></pre><p>而如果使用了var及类型推导，只需要改下首行代码便可以了，其它代码无需改动：</p>
<pre><code>var countryToCity = new HashMap&lt;String, List&lt;City&amp;gt;&amp;gt;();
// ...
for (var citiesInCountry : countryToCity.entrySet()) {
    var cities = citiesInCountry.getValue();
// ...
}</code></pre><p>这个例子说明了var使用的一个关键原则：不要为了读写代码方便而进行优化，而应该优化可维护性。如果奔着可维护性去优化代码，随着程序的不断迭代，自然会在可读性和代码量上能找到平衡点。</p>
<p>很难说使用了类型推导就一定能够对代码有所提升——有的时候显式类型会让代码的可读性更强一些。尤其是当表达式中不容易看出具体类型时。下面的代码最好还是使用显式类型，因为光看getCities()你是不知道它返回了什么的：</p>
<pre><code>Map&lt;String, List&lt;City&amp;gt;&amp;gt; countryToCity = getCities();
var countryToCity = getCities();</code></pre><p>关于var和可读性间的权衡，终极建议是：使用好变量名！由于var省略了变量的类型，读代码的人只能去猜测代码的真实意图，因此作为开发人员更有义务要为局部变量取一个好的名字。理论上来说这也是Java开发人员应该做的。不过在实践中，其实Java代码的很多可读性问题并不是语言特性引起的，更多还是目前大家的做法导致的，比如说变量命名。</p>
<p>类型推导及IDE<br>许多IDE都提供了局部变量提取（extract local variable）的功能，它们能推导出正确的类型并且生成代码。这个特性和Java 10中的var关键字的功能有些重叠。IDE和var都能节省手动输入类型的工作量，不过它们有着不同的取舍。</p>
<p>提取功能会在代码中生成一个拥有完整类型信息的局部变量，而var则彻底消除了在代码中声明类型的必要。尽管它们在简少代码编写上的作用是相似的，但var或多或少改变了可读性而提取功能则没有。正如前面所说的，大多数情况下var还是能提升可读性的，不过有的时候又变成了阻碍。</p>
<p>和其它语言相比<br>Java不是首个也不是唯一一个进行类型推导的语言。事实上Java 10所引入的类弄推导功能仍非常有限。目前var的推导算法只检查了变量的赋值表达式，保证了实现的简单以及编译器报错能直接到关联到具体的var语句上。</p>
<p>结论<br>从提高生产效率和可读性方面来看，var的类型推导是Java语言的一个有效的补充，不过这只是一个开始。未来的Java版本仍会继续稳步推进语言的革新及现代化。比如在Java 10发布后仅过了6个月便发布的长期支持版的Java 11中，var关键字便可用于lambda表达式的参数中。这样便可以推导出参数的类型，并且仍然可以使用注解，比如这样：</p>
<pre><code>(@Nonnull var x, var y) -&gt; x.process(y)</code></pre><p>而函数式编程语言中已经成为主流的一些做法也会陆续加入到未来的Java版本中来——比如说模式匹配和值类型。加入这些优化并非意味着Java不再是那个开发人员所熟知和喜爱的语言了。相反，Java会变为一门更灵活，可读性更强，更简洁的语言。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leilei666.github.io/my-blog/2019/09/14/java 10的类型推导/" data-id="ck3jwi95e000dz4w1sg12demi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-profile介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/09/07/profile介绍/" class="article-date">
  <time datetime="2019-09-07T07:05:10.000Z" itemprop="datePublished">2019-09-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/09/07/profile介绍/">profile介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Profile主要用于区分不同的环境。</p>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><h3 id="2-1-Profile"><a href="#2-1-Profile" class="headerlink" title="2.1 @Profile"></a>2.1 @Profile</h3><p>在某个类、或者方法上添加@Profile注解，指定具体的profile环境标签，那么只有在该profile处于active的情况下该类、方法才会被加载、执行。</p>
<pre><code>@Profile({&quot;dev&quot;,&quot;test&quot;})
public class Xxx{

    @Profile({&quot;dev&quot;})
    @Bean
    public Xxx xxx(){
        return new Xxx();
    }
}</code></pre><h3 id="2-2-多环境配置"><a href="#2-2-多环境配置" class="headerlink" title="2.2 多环境配置"></a>2.2 多环境配置</h3><h4 id="2-2-1-properties配置文件"><a href="#2-2-1-properties配置文件" class="headerlink" title="2.2.1 properties配置文件"></a>2.2.1 properties配置文件</h4><pre><code>使用properties配置文件实现多环境配置，只能通过添加多个application-{profile}.properties来实现。

比如：application-dev.properties,application-test.properties</code></pre><h4 id="2-2-2-YAML配置文件"><a href="#2-2-2-YAML配置文件" class="headerlink" title="2.2.2 YAML配置文件"></a>2.2.2 YAML配置文件</h4><p>使用YAML实现多环境配置要简单的多，只需要一个文件即可，application.yml</p>
<p>在文件中使用—来区分多个环境，每个环境都需要配置spring.profile属性，不配置的属于默认环境</p>
<pre><code>server:
  port: 8080</code></pre><p>属性映射测试</p>
<pre><code>spring:
  profiles: dev
server:
  port: 8081
---
spring:
  profiles: test
server:
  port: 8082
---
spring:
  profiles: pro
server:
  port: 8083</code></pre><h3 id="2-3-激活profiles"><a href="#2-3-激活profiles" class="headerlink" title="2.3 激活profiles"></a>2.3 激活profiles</h3><p>可以在命令行参数、系统参数、application.properties等处进行配置</p>
<h4 id="2-3-1-命令行"><a href="#2-3-1-命令行" class="headerlink" title="2.3.1 命令行"></a>2.3.1 命令行</h4><pre><code>--spring.profiles.active=dev</code></pre><h4 id="2-3-2-application-properties"><a href="#2-3-2-application-properties" class="headerlink" title="2.3.2 application.properties"></a>2.3.2 application.properties</h4><pre><code>spring.profiles.active=dev</code></pre><h3 id="2-4-添加profiles"><a href="#2-4-添加profiles" class="headerlink" title="2.4 添加profiles"></a>2.4 添加profiles</h3><p>我们可以在不修改已启动的profiles的基础上添加新的profiles</p>
<p>使用spring.profiles.include属性进行配置</p>
<p>还可以使用编程的方式实现，使用如下的方式添加：</p>
<pre><code>SpringApplication.setAdditionalProfiles(&quot;development&quot;);</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://leilei666.github.io/my-blog/2019/09/07/profile介绍/" data-id="ck3jwi94p0007z4w17jm3mi5z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RabbitMQ消息中间件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/08/30/RabbitMQ消息中间件/" class="article-date">
  <time datetime="2019-08-30T05:55:56.000Z" itemprop="datePublished">2019-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/08/30/RabbitMQ消息中间件/">RabbitMQ消息中间件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、RabbitMQ起步"><a href="#一、RabbitMQ起步" class="headerlink" title="一、RabbitMQ起步"></a>一、RabbitMQ起步</h2><h3 id="1、RabbitMQ简介"><a href="#1、RabbitMQ简介" class="headerlink" title="1、RabbitMQ简介"></a>1、RabbitMQ简介</h3><h4 id="1-1、什么是RabbitMQ？"><a href="#1-1、什么是RabbitMQ？" class="headerlink" title="1.1、什么是RabbitMQ？"></a>1.1、什么是RabbitMQ？</h4><p>RabbitMQ是一个开元的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，RabbitMQ是使用Erlang语言来编写的，并且RabbitMQ是基于 AMQP协议的。</p>
<h4 id="1-2、RabbitMQ有哪些特点？"><a href="#1-2、RabbitMQ有哪些特点？" class="headerlink" title="1.2、RabbitMQ有哪些特点？"></a>1.2、RabbitMQ有哪些特点？</h4><p>目前大多数互联网都在使用RabbitMQ</p>
<p>RabbitMQ底层采用Erlang语言进行编写</p>
<p>开源、性能优秀，稳定</p>
<p>与SpringAMQP完美的整合、API丰富</p>
<p>集群模式丰富，表达式配置，HA模式，镜像队列模型</p>
<p>保证数据不丢失的前提做到高可靠、可用性</p>
<h3 id="2、RabbitMQ安装和使用"><a href="#2、RabbitMQ安装和使用" class="headerlink" title="2、RabbitMQ安装和使用"></a>2、RabbitMQ安装和使用</h3><p>官方下载地址：<a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></p>
<h3 id="3、RabbitMQ核心概念"><a href="#3、RabbitMQ核心概念" class="headerlink" title="3、RabbitMQ核心概念"></a>3、RabbitMQ核心概念</h3><p>Server：又称Broker（实体服务） 接收客户端的连接。实现AMQP实体服务</p>
<p>Connection：连接，应用程序与Broker的网络连接</p>
<p>Channel ：网络信道，几乎所有的操作都在Chanel中进行，Channel是进行消息读写的通道。客户端可建立多个Channel，每个Channel代表一个</p>
<p>会话任务</p>
<p>Message：消息，服务器和应用程序之间传送的数据，由Properties和Body组成。Properties可以对消息进行修饰，比如消息的优先级，延迟等高级特性；Body则就是消息体内容。</p>
<p>Virtual host：虚拟地址，用于进行逻辑隔离，最上层的消息路由。一个</p>
<p>Virtual host里面可以有若干个Exchange和Queue，同一个Virtual host里面不能有相同名称的Exchange或Queue（用于隔离不同的项目和应用的）</p>
<p>Exchange：交换机，接收消息，根据路由键转发消息到绑定的队列</p>
<p>Binding：Exchange和Queue之间的虚拟连接，binding中可以包含routing key</p>
<p>Routing key：一个路由规则，虚拟机可用它来确定如何路由一个特定消息</p>
<p>Queue：也称为Message Queue,消息队列，保存消息并将它们转发给消费者，消费者直接监听队列就能收到消息了</p>
<h2 id="二、RabbitMQ整合Spring-Boot2-x"><a href="#二、RabbitMQ整合Spring-Boot2-x" class="headerlink" title="二、RabbitMQ整合Spring Boot2.x"></a>二、RabbitMQ整合Spring Boot2.x</h2><p>1、生产端基本配置application.properties</p>
<pre><code>spring.rabbitmq.addresses=localhost:5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guestspring.rabbitmq.virtual-host=/
spring.rabbitmq.connection-timeout=15000server.servlet.context-path=/server.port=8001
spring.http.encoding.charset=UTF-8spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8spring.jackson.default-property-inclusion=NON_NULL</code></pre><p>2、生产端发送消息</p>
<p>3、配置rabbitmq的exchange和queue，并让二者建立关联关系</p>
<p>4、消息发送成功</p>
<p>5、消费端配置application.properties</p>
<p>springboot整合rabbitmq基本配置</p>
<pre><code>spring.rabbitmq.addresses=localhost:5672
spring.rabbitmq.username=guest
spring.rabbitmq.password=guest
spring.rabbitmq.virtual-host=/spring.rabbitmq.connection-timeout=15000</code></pre><p>springboot整合rabbitmq消费端配置</p>
<pre><code>spring.rabbitmq.listener.simple.concurrency=5
spring.rabbitmq.listener.simple.acknowledge-mode=manual
spring.rabbitmq.listener.simple.max-concurrency=10</code></pre><p>限流</p>
<pre><code>spring.rabbitmq.listener.simple.prefetch=1server.servlet.context-path=/server.port=8002
spring.http.encoding.charset=UTF-8spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8spring.jackson.default-property-inclusion=NON_NULL</code></pre><h2 id="三、消息100-可靠性投递的解决方案实现"><a href="#三、消息100-可靠性投递的解决方案实现" class="headerlink" title="三、消息100%可靠性投递的解决方案实现"></a>三、消息100%可靠性投递的解决方案实现</h2><p>Step 1： 首先把消息信息(业务数据）存储到数据库中，紧接着，我们再把这个消息记录也存储到一张消息记录表里（或者另外一个同源数据库的消息记录表）</p>
<p>Step 2：发送消息到MQ Broker节点（采用confirm方式发送，会有异步的返回结果）</p>
<p>Step 3、4：生产者端接受MQ Broker节点返回的Confirm确认消息结果，然后进行更新消息记录表里的消息状态。比如默认Status = 0 当收到消息确认成功后，更新为1即可！</p>
<p>Step 5：但是在消息确认这个过程中可能由于网络闪断、MQ Broker端异常等原因导致 回送消息失败或者异常。这个时候就需要发送方（生产者）对消息进行可靠性投递了，保障消息不丢失，100%的投递成功！（有一种极限情况是闪断，Broker返回的成功确认消息，但是生产端由于网络闪断没收到，这个时候重新投递可能会造成消息重复，需要消费端去做幂等处理）所以我们需要有一个定时任务，（比如每5分钟拉取一下处于中间状态的消息，当然这个消息可以设置一个超时时间，比如超过1分钟 Status = 0 ，也就说明了1分钟这个时间窗口内，我们的消息没有被确认，那么会被定时任务拉取出来）</p>
<p>Step 6：接下来我们把中间状态的消息进行重新投递 retry send，继续发送消息到MQ ，当然也可能有多种原因导致发送失败</p>
<p>Step 7：我们可以采用设置最大努力尝试次数，比如投递了3次，还是失败，那么我们可以将最终状态设置为Status = 2 ，最后 交由人工解决处理此类问题（或者把消息转储到失败表中）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leilei666.github.io/my-blog/2019/08/30/RabbitMQ消息中间件/" data-id="ck3jwi93x0000z4w1c9k4vmj4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sql技巧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/08/23/sql技巧/" class="article-date">
  <time datetime="2019-08-23T10:24:38.000Z" itemprop="datePublished">2019-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/08/23/sql技巧/">sql技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于数据过滤而言CHECK约束已经算是相当不错了。然而它仍存在一些缺陷，比如说它们是应用到表上面的，但有的时候你可能希望指定一条约束，而它只在特定条件下才生效。</p>
<p>使用SQL标准的WITH CHECK OPTION子句就能完成这点，至少Oracle和SQL Server都实现了这个功能。下面是实现方式：</p>
<pre><code>CREATE TABLE books (
  id    NUMBER(10)         NOT NULL,
  title VARCHAR2(100 CHAR) NOT NULL,
  price NUMBER(10, 2)      NOT NULL,

  CONSTRAINT pk_book PRIMARY KEY (id)
);
/

CREATE VIEW expensive_books
AS
SELECT id, title, price
FROM books
WHERE price &gt; 100
WITH CHECK OPTION;
/

INSERT INTO books 
VALUES (1, &apos;1984&apos;, 35.90);

INSERT INTO books 
VALUES (
, 
  &apos;The Answer to Life, the Universe, and Everything&apos;,
.90
);</code></pre><p>正如你看到的那样，expensive_books 是那些价格大于100块的书。这个视图只会返回第二本书：</p>
<p>SELECT * FROM expensive_books;</p>
<p>上述查询的输出是：</p>
<pre><code>ID TITLE                                       PRICE
-- ----------------------------------------- -------
 The Answer to Life, the Universe, and ...   999.9 </code></pre><p>不过由于我们使用了CHECK OPTION，我们还能防止用户往”昂贵的书籍”中插入那些廉价的。比如说，我们运行下这个查询：</p>
<pre><code>INSERT INTO expensive_books 
VALUES (3, &apos;10 Reasons why jOOQ is Awesome&apos;, 9.99);</code></pre><p>它是无法生效的。你会看到：</p>
<pre><code>ORA-01402: view WITH CHECK OPTION where-clause violation</code></pre><p>我们也无法将贵的书更新成便宜的：</p>
<pre><code>UPDATE expensive_books
SET price = 9.99;</code></pre><p>这个查询也会报出同样的ORA-01402错误。</p>
<pre><code>WITH CHECK OPTION内联</code></pre><p>如果你需要局部防止脏数据被插入到表中，你可以使用WITH CHECK OPTION的内联子句：</p>
<pre><code>INSERT INTO (
  SELECT *
  FROM expensive_books
  WHERE price &gt; 1000
  WITH CHECK OPTION
) really_expensive_books
VALUES (3, &apos;Modern Enterprise Software&apos;, 999.99);</code></pre><p>上述查询同样也会导到ORA-01402错误。</p>
<p>使用SQL转换来生成特殊约束<br>CHECK OPTION对于已存储的视图非常有用，它使得那些无权直接访问底层表的用户能够获得正确的授权，而内联的CHECK OPTION主要是在应用的SQL中间转换层来进行动态SQL的转换。</p>
<p>这个可以通过[jOOQ的SQL转换功能]<a href="http://www.jooq.org/doc/latest/manual/sql-building/queryparts/custom-sql-transformation/url)来完成，比如说，你可以在SQL语句中对某个表进行约束，从根本上阻止了非法DML的执行。如果你的数据库没有本地提供行级别的安全性的话，这也是一个实现多租户的不错的方式" target="_blank" rel="noopener">http://www.jooq.org/doc/latest/manual/sql-building/queryparts/custom-sql-transformation/url)来完成，比如说，你可以在SQL语句中对某个表进行约束，从根本上阻止了非法DML的执行。如果你的数据库没有本地提供行级别的安全性的话，这也是一个实现多租户的不错的方式</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leilei666.github.io/my-blog/2019/08/23/sql技巧/" data-id="ck3jwi94s0008z4w1wpyd0sgi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java-8新的时间日期库的20个使用实例" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blog/2019/08/16/Java-8新的时间日期库的20个使用实例/" class="article-date">
  <time datetime="2019-08-16T06:50:32.000Z" itemprop="datePublished">2019-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blog/2019/08/16/Java-8新的时间日期库的20个使用实例/">Java 8新的时间日期库的20个使用实例</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>除了lambda表达式，stream以及几个小的改进之外，Java 8还引入了一套全新的时间日期API，在本篇教程中我们将通过几个简单的任务示例来学习如何使用Java 8的这套API。Java对日期，日历及时间的处理一直以来都饱受诟病，尤其是它决定将java.util.Date定义为可修改的以及将SimpleDateFormat实现成非线程安全的。看来Java已经意识到需要为时间及日期功能提供更好的支持了，这对已经习惯使用Joda时间日期库的社区而言也是件好事。关于这个新的时间日期库的最大的优点就在于它定义清楚了时间日期相关的一些概念，比方说，瞬时时间（Instant）,持续时间（duration），日期（date）,时间（time），时区（time-zone）以及时间段（Period）。同时它也借鉴了Joda库的一些优点，比如将人和机器对时间日期的理解区分开的。Java 8仍然延用了ISO的日历体系，并且与它的前辈们不同，java.time包中的类是不可变且线程安全的。新的时间及日期API位于java.time包中，下面是里面的一些关键的类：</p>
<pre><code>Instant——它代表的是时间戳
LocalDate——不包含具体时间的日期，比如2014-01-14。它可以用来存储生日，周年纪念日，入职日期等。
LocalTime——它代表的是不含日期的时间
LocalDateTime——它包含了日期及时间，不过还是没有偏移信息或者说时区。
ZonedDateTime——这是一个包含时区的完整的日期时间，偏移量是以UTC/格林威治时间为基准的。</code></pre><p>新的库还增加了ZoneOffset及Zoned，可以为时区提供更好的支持。有了新的DateTimeFormatter之后日期的解析及格式化也变得焕然一新了。随便提一句，我是在去年这个时候Java正要推出这个新功能时写的这篇文章，所以你会发现示例中的时间都还是去年的。你运行下这些例子，它们返回的值肯定都是正确的。</p>
<p>Java 8是如何处理时间及日期的<br>有人问我学习一个新库的最佳途径是什么？我的回答是，就是在实际项目中那样去使用它。在一个真实的项目中会有各种各样的需求，这会促使开发人员去探索和研究这个新库。简言之，只有任务本身才会真正促使你去探索及学习。java 8的新的日期及时间API也是一样。为了学习Java 8的这个新库，这里我创建了20个以任务为导向的例子。我们先从一个简单的任务开始，比如说如何用Java 8的时间日期库来表示今天，接着再进一步生成一个带时间及时区的完整日期，然后再研究下如何完成一些更实际的任务，比如说开发一个提醒类的应用，来找出距离一些特定日期比如生日，周日纪念日，下一个帐单日，下一个溢价日或者信用卡过期时间还有多少天。</p>
<p>示例1 如何 在Java 8中获取当天的日期<br>Java 8中有一个叫LocalDate的类，它能用来表示今天的日期。这个类与java.util.Date略有不同，因为它只包含日期，没有时间。因此，如果你只需要表示日期而不包含时间，就可以使用它。</p>
<pre><code>LocalDate today = LocalDate.now(); System.out.println(&quot;Today&apos;s Local date : &quot; + today); 
Output 
Today&apos;s Local date : 2014-01-14</code></pre><p>你可以看到它创建了今天的日期却不包含时间信息。它还将日期格式化完了再输出出来，不像之前的Date类那样，打印出来的数据都是未经格式化的。</p>
<p>示例2 如何在Java 8中获取当前的年月日<br>LocalDate类中提供了一些很方便的方法可以用于提取出年月日以及其它的日期属性。使用这些方法，你可以获取到任何你所需要的日期属性，而不再需要使用java.util.Calendar这样的类了：</p>
<pre><code>LocalDate today = LocalDate.now(); 
int year = today.getYear(); 
int month = today.getMonthValue(); 
int day = today.getDayOfMonth(); 
System.out.printf(&quot;Year : %d Month : %d day : %d \t %n&quot;, year, month, day); 

Output 
Today&apos;s Local date : 2014-01-14 
Year : 2014 Month : 1 day : 14 </code></pre><p>可以看到，在Java 8中获取年月信息非常简单，只需使用对应的getter方法就好了，无需记忆，非常直观。你可以拿它和Java中老的获取当前年月日的写法进行一下比较。</p>
<p>示例3 在Java 8中如何获取某个特定的日期<br>在第一个例子中，我们看到通过静态方法now()来生成当天日期是非常简单的，不过通过另一个十分有用的工厂方法LocalDate.of()，则可以创建出任意一个日期，它接受年月日的参数，然后返回一个等价的LocalDate实例。关于这个方法还有一个好消息就是它没有再犯之前API中的错，比方说，年只能从1900年开始，月必须从0开始，等等。这里的日期你写什么就是什么，比如说，下面这个例子中它代表的就是1月14日，没有什么隐藏逻辑。</p>
<pre><code>LocalDate dateOfBirth = LocalDate.of(2010, 01, 14); 
System.out.println(&quot;Your Date of birth is : &quot; + dateOfBirth); 

Output : Your Date of birth is : 2010-01-14</code></pre><p>可以看出，创建出来的日期就是我们所写的那样，2014年1月14日。</p>
<p>示例4 在Java 8中如何检查两个日期是否相等<br>如果说起现实中实际的处理时间及日期的任务，有一个常见的就是要检查两个日期是否相等。你可能经常会碰到要判断今天是不是某个特殊的日子，比如生日啊，周年纪念日啊，或者假期之类。有的时候，会给你一个日期，让你检查它是不是某个日子比方说假日。下面这个例子将会帮助你在Java 8中完成这类任务。正如你所想的那样，LocalDate重写了equals方法来进行日期的比较，如下所示</p>
<pre><code>LocalDate date1 = LocalDate.of(2014, 01, 14); if(date1.equals(today)){ 
    System.out.printf(&quot;Today %s and date1 %s are same date %n&quot;, today, date1); 
} 

Output 
today 2014-01-14 and date1 2014-01-14 are same date</code></pre><p>在本例中我们比较的两个日期是相等的。同时，如果在代码中你拿到了一个格式化好的日期串，你得先将它解析成日期然后才能比较。你可以将这个例子与Java之前比较日期的方式进行下比较，你会发现它真是爽多了。</p>
<p>示例5 在Java 8中如何检查重复事件，比如说生日<br>在Java中还有一个与时间日期相关的实际任务就是检查重复事件，比如说每月的帐单日，结婚纪念日，每月还款日或者是每年交保险费的日子。如果你在一家电商公司工作的话，那么肯定会有这么一个模块，会去给用户发送生日祝福并且在每一个重要的假日给他们捎去问候，比如说圣诞节，感恩节，在印度则可能是万灯节（Deepawali）。如何在Java中判断是否是某个节日或者重复事件？使用MonthDay类。这个类由月日组合，不包含年信息，也就是说你可以用它来代表每年重复出现的一些日子。当然也有一些别的组合，比如说YearMonth类。它和新的时间日期库中的其它类一样也都是不可变且线程安全的，并且它还是一个值类（value class）。我们通过一个例子来看下如何使用MonthDay来检查某个重复的日期</p>
<pre><code>LocalDate dateOfBirth = LocalDate.of(2010, 01, 14); 
MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth()); 
MonthDay currentMonthDay = MonthDay.from(today); 
if(currentMonthDay.equals(birthday)){ 
System.out.println(&quot;Many Many happy returns of the day !!&quot;); 
}else{ 
    System.out.println(&quot;Sorry, today is not your birthday&quot;); 
} 

Output: Many Many happy returns of the day !!</code></pre><p>虽然年不同，但今天就是生日的那天，所以在输出那里你会看到一条生日祝福。你可以调整下系统的时间再运行下这个程序看看它是否能提醒你下一个生日是什么时候，你还可以试着用你的下一个生日来编写一个JUnit单元测试看看代码能否正确运行。</p>
<p>示例6 如何在Java 8中获取当前时间<br>这与第一个例子中获取当前日期非常相似。这次我们用的是一个叫LocalTime的类，它是没有日期的时间，与LocalDate是近亲。这里你也可以用静态工厂方法now()来获取当前时间。默认的格式是hh:mm:ss:nnn，这里的nnn是纳秒。可以和Java 8以前如何获取当前时间做一下比较。</p>
<pre><code>LocalTime time = LocalTime.now(); System.out.println(&quot;local time now : &quot; + time);

Output 
local time now : 16:33:33.369 // in hour, minutes, seconds, nano seconds</code></pre><p>可以看到，当前时间是不包含日期的，因为LocalTime只有时间，没有日期。</p>
<p>示例7 如何增加时间里面的小时数<br>很多时候我们需要增加小时，分或者秒来计算出将来的时间。Java 8不仅提供了不可变且线程安全的类，它还提供了一些更方便的方法譬如plusHours()来替换原来的add()方法。顺便说一下，这些方法返回的是一个新的LocalTime实例的引用，因为LocalTime是不可变的，可别忘了存储好这个新的引用</p>
<pre><code>LocalTime time = LocalTime.now(); 
LocalTime newTime = time.plusHours(2); // adding two hours 
System.out.println(&quot;Time after 2 hours : &quot; + newTime); 

Output : 
Time after 2 hours : 18:33:33.369</code></pre><p>可以看到当前时间2小时后是16:33:33.369。现在你可以将它和Java中增加或者减少小时的老的方式进行下比较。一看便知哪种方式更好。</p>
<p>示例8 如何获取1周后的日期<br>这与前一个获取2小时后的时间的例子类似，这里我们将学会如何获取到1周后的日期。LocalDate是用来表示无时间的日期的，它有一个plus()方法可以用来增加日，星期，或者月，ChronoUnit则用来表示这个时间单位。由于LocalDate也是不可变的，因此任何修改操作都会返回一个新的实例，因此别忘了保存起来</p>
<pre><code>LocalDate nextWeek = today.plus(1, ChronoUnit.WEEKS); 
System.out.println(&quot;Today is : &quot; + today); 
System.out.println(&quot;Date after 1 week : &quot; + nextWeek); 


Output: 
Today is : 2014-01-14 
Date after 1 week : 2014-01-21</code></pre><p>可以看到7天也就是一周后的日期是什么。你可以用这个方法来增加一个月，一年，一小时，一分钟，甚至是十年，查看下Java API中的ChronoUnit类来获取更多选项。</p>
<p>示例9 一年前后的日期<br>这是上个例子的续集。上例中，我们学习了如何使用LocalDate的plus()方法来给日期增加日，周或者月，现在我们来学习下如何用minus()方法来找出一年前的那天</p>
<pre><code>LocalDate previousYear = today.minus(1, ChronoUnit.YEARS); 
System.out.println(&quot;Date before 1 year : &quot; + previousYear); 
LocalDate nextYear = today.plus(1, YEARS); 
System.out.println(&quot;Date after 1 year : &quot; + nextYear); 

Output: 
Date before 1 year : 2013-01-14 
Date after 1 year : 2015-01-14</code></pre><p>可以看到现在一共有两年，一个是2013年，一个是2015年，分别是2014的前后那年。</p>
<p>示例10 在Java 8中使用时钟<br>Java 8中自带了一个Clock类，你可以用它来获取某个时区下当前的瞬时时间，日期或者时间。可以用Clock来替代System.currentTimeInMillis()与 TimeZone.getDefault()方法。</p>
<pre><code>// Returns the current time based on your system clock and set to UTC. 
Clock clock = Clock.systemUTC(); 
System.out.println(&quot;Clock : &quot; + clock); 

// Returns time based on system clock zone Clock defaultClock = 
Clock.systemDefaultZone(); 
System.out.println(&quot;Clock : &quot; + clock); 

Output: 
Clock : SystemClock[Z] 
Clock : SystemClock[Z]</code></pre><p>你可以用指定的日期来和这个时钟进行比较，比如下面这样：</p>
<pre><code>public class MyClass { 
    private Clock clock; // dependency inject ... 

    public void process(LocalDate eventDate) { 

        if(eventDate.isBefore(LocalDate.now(clock)) { 
            ... 
        } 
    } 
}</code></pre><p>如果你需要对不同时区的日期进行处理的话这是相当方便的。</p>
<p>示例11 在Java中如何判断某个日期是在另一个日期的前面还是后面<br>这也是实际项目中常见的一个任务。你怎么判断某个日期是在另一个日期的前面还是后面，或者正好相等呢？在Java 8中，LocalDate类有一个isBefore()和isAfter()方法可以用来比较两个日期。如果调用方法的那个日期比给定的日期要早的话，isBefore()方法会返回true。</p>
<pre><code>LocalDate tomorrow = LocalDate.of(2014, 1, 15); 、if(tommorow.isAfter(today)){ 
    System.out.println(&quot;Tomorrow comes after today&quot;); 
} 
LocalDate yesterday = today.minus(1, DAYS); 
if(yesterday.isBefore(today)){ 
    System.out.println(&quot;Yesterday is day before today&quot;); 
} 

Output: 
Tomorrow comes after today 
Yesterday is day before today</code></pre><p>可以看到在Java 8中进行日期比较非常简单。不需要再用像Calendar这样的另一个类来完成类似的任务了。</p>
<p>示例12 在Java 8中处理不同的时区<br>Java 8不仅将日期和时间进行了分离，同时还有时区。现在已经有好几组与时区相关的类了，比如ZonId代表的是某个特定的时区，而ZonedDateTime代表的是带时区的时间。它等同于Java 8以前的GregorianCalendar类。使用这个类，你可以将本地时间转换成另一个时区中的对应时间，比如下面这个例子：</p>
<pre><code>// Date and time with timezone in Java 8 ZoneId america = ZoneId.of(&quot;America/New_York&quot;); 
LocalDateTime localtDateAndTime = LocalDateTime.now(); 
ZonedDateTime dateAndTimeInNewYork = ZonedDateTime.of(localtDateAndTime, america ); 
System.out.println(&quot;Current date and time in a particular timezone : &quot; + dateAndTimeInNewYork); 

Output : 
Current date and time in a particular timezone : 2014-01-14T16:33:33.373-05:00[America/New_York]</code></pre><p>可以拿它跟之前将本地时间转换成GMT时间的方式进行下比较。顺便说一下，正如Java 8以前那样，对应时区的那个文本可别弄错了，否则你会碰到这么一个异常：</p>
<pre><code>Exception in thread &quot;main&quot; java.time.zone.ZoneRulesException: Unknown time-zone ID: ASIA/Tokyo
        at java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:272)
        at java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:227)
        at java.time.ZoneRegion.ofId(ZoneRegion.java:120)
        at java.time.ZoneId.of(ZoneId.java:403)
        at java.time.ZoneId.of(ZoneId.java:351)  </code></pre><p>示例13 如何表示固定的日期，比如信用卡过期时间<br>正如MonthDay表示的是某个重复出现的日子的，YearMonth又是另一个组合，它代表的是像信用卡还款日，定期存款到期日，options到期日这类的日期。你可以用这个类来找出那个月有多少天，lengthOfMonth()这个方法返回的是这个YearMonth实例有多少天，这对于检查2月到底是28天还是29天可是非常有用的。</p>
<pre><code>YearMonth currentYearMonth = YearMonth.now(); System.out.printf(&quot;Days in month year %s: %d%n&quot;, currentYearMonth, currentYearMonth.lengthOfMonth()); 
YearMonth creditCardExpiry = YearMonth.of(2018, Month.FEBRUARY); 
System.out.printf(&quot;Your credit card expires on %s %n&quot;, creditCardExpiry); 

Output: 
Days in month year 2014-01: 31 
Your credit card expires on 2018-02   </code></pre><p>示例14 如何在Java 8中检查闰年<br>这并没什么复杂的，LocalDate类有一个isLeapYear()的方法能够返回当前LocalDate对应的那年是否是闰年。如果你还想重复造轮子的话，可以看下这段代码，这是纯用Java编写的判断某年是否是闰年的逻辑。</p>
<pre><code>if(today.isLeapYear()){ 
    System.out.println(&quot;This year is Leap year&quot;); 
}else { 
    System.out.println(&quot;2014 is not a Leap year&quot;); 
} 


Output: 2014 is not a Leap year</code></pre><p>你可以多检查几年看看结果是否正确，最好写一个单元测试来对正常年份和闰年进行下测试。</p>
<p>示例15 两个日期之间包含多少天，多少个月<br>还有一个常见的任务就是计算两个给定的日期之间包含多少天，多少周或者多少年。你可以用java.time.Period类来完成这个功能。在下面这个例子中，我们将计算当前日期与将来的一个日期之前一共隔着几个月。</p>
<pre><code>LocalDate java8Release = LocalDate.of(2014, Month.MARCH, 14); 
Period periodToNextJavaRelease = 
Period.between(today, java8Release); 
System.out.println(&quot;Months left between today and Java 8 release : &quot; + periodToNextJavaRelease.getMonths() ); 

Output: 
Months left between today and Java 8 release : 2</code></pre><p>可以看到，本月是1月，而Java 8的发布日期是3月，因此中间隔着2个月。</p>
<p>示例16 带时区偏移量的日期与时间<br>在Java 8里面，你可以用ZoneOffset类来代表某个时区，比如印度是GMT或者UTC5：30，你可以使用它的静态方法ZoneOffset.of()方法来获取对应的时区。只要获取到了这个偏移量，你就可以拿LocalDateTime和这个偏移量创建出一个OffsetDateTime。</p>
<pre><code>LocalDateTime datetime = LocalDateTime.of(2014, Month.JANUARY, 14, 19, 30); 
ZoneOffset offset = ZoneOffset.of(&quot;+05:30&quot;); 
OffsetDateTime date = OffsetDateTime.of(datetime, offset); 
System.out.println(&quot;Date and Time with timezone offset in Java : &quot; + date); 

Output : 
Date and Time with timezone offset in Java : 2014-01-14T19:30+05:30</code></pre><p>可以看到现在时间日期与时区是关联上了。还有一点就是，OffSetDateTime主要是给机器来理解的，如果是给人看的，可以使用ZoneDateTime类。</p>
<p>示例17 在Java 8中如何获取当前时间戳<br>如果你还记得在Java 8前是如何获取当前时间戳的，那现在这简直就是小菜一碟了。Instant类有一个静态的工厂方法now()可以返回当前时间戳，如下：</p>
<pre><code>Instant timestamp = Instant.now(); 
System.out.println(&quot;What is value of this instant &quot; + timestamp); 

Output : 
What is value of this instant 2014-01-14T08:33:33.379Z</code></pre><p>可以看出，当前时间戳是包含日期与时间的，与java.util.Date很类似，事实上Instant就是Java 8前的Date，你可以使用这两个类中的方法来在这两个类型之间进行转换，比如Date.from(Instant)是用来将Instant转换成java.util.Date的，而Date.toInstant()是将Date转换成Instant的。</p>
<p>示例18 如何在Java 8中使用预定义的格式器来对日期进行解析/格式化<br>在Java 8之前，时间日期的格式化可是个技术活，我们的好伙伴SimpleDateFormat并不是线程安全的，而如果用作本地变量来格式化的话又显得有些笨重。多亏了线程本地变量，这使得它在多线程环境下也算有了用武之地，但Java维持这一状态也有很长一段时间了。这次它引入了一个全新的线程安全的日期与时间格式器。它还自带了一些预定义好的格式器，包含了常用的日期格式。比如说，本例 中我们就用了预定义的BASICISODATE格式，它会将2014年2月14日格式化成20140114。</p>
<pre><code>String dayAfterTommorrow = &quot;20140116&quot;; 
LocalDate formatted = LocalDate.parse(dayAfterTommorrow, 
DateTimeFormatter.BASIC_ISO_DATE); 
System.out.printf(&quot;Date generated from String %s is %s %n&quot;, dayAfterTommorrow, formatted); 

Output : 
Date generated from String 20140116 is 2014-01-16</code></pre><p>你可以看到生成的日期与指定字符串的值是匹配的，就是日期格式上略有不同。</p>
<p>示例19 如何在Java中使用自定义的格式器来解析日期<br>在上例中，我们使用了内建的时间日期格式器来解析日期字符串。当然了，预定义的格式器的确不错但有时候你可能还是需要使用自定义的日期格式，这个时候你就得自己去创建一个自定义的日期格式器实例了。下面这个例子中的日期格式是”MMM dd yyyy”。你可以给DateTimeFormatter的ofPattern静态方法()传入任何的模式，它会返回一个实例，这个模式的字面量与前例中是相同的。比如说M还是代表月，而m仍是分。无效的模式会抛出DateTimeParseException异常，但如果是逻辑上的错误比如说该用M的时候用成m，这样就没办法了。</p>
<pre><code>String goodFriday = &quot;Apr 18 2014&quot;; 
try { 
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;MMM dd yyyy&quot;);     
    LocalDate holiday = LocalDate.parse(goodFriday, formatter); 
    System.out.printf(&quot;Successfully parsed String %s, date is %s%n&quot;, goodFriday, holiday); 
} catch (DateTimeParseException ex) { 
    System.out.printf(&quot;%s is not parsable!%n&quot;, goodFriday); 
    ex.printStackTrace(); 
} 

Output : 
Successfully parsed String Apr 18 2014, date is 2014-04-18</code></pre><p>可以看到日期的值与传入的字符串的确是相符的，只是格式不同。</p>
<p>示例20 如何在Java 8中对日期进行格式化，转换成字符串<br>在上两个例子中，尽管我们用到了DateTimeFormatter类但我们主要是进行日期字符串的解析。在这个例子中我们要做的事情正好相反。这里我们有一个LocalDateTime类的实例，我们要将它转换成一个格式化好的日期串。这是目前为止Java中将日期转换成字符串最简单便捷的方式了。下面这个例子将会返回一个格式化好的字符串。与前例相同的是，我们仍需使用指定的模式串去创建一个DateTimeFormatter类的实例，但调用的并不是LocalDate类的parse方法，而是它的format()方法。这个方法会返回一个代表当前日期的字符串，对应的模式就是传入的DateTimeFormatter实例中所定义好的。</p>
<pre><code>LocalDateTime arrivalDate = LocalDateTime.now(); 
try { 
    DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;MMM dd yyyy hh:mm a&quot;); 
    String landing = arrivalDate.format(format); 
    System.out.printf(&quot;Arriving at : %s %n&quot;, landing); 
    } catch (DateTimeException ex) { 
    System.out.printf(&quot;%s can&apos;t be formatted!%n&quot;, arrivalDate); 
    ex.printStackTrace(); 
} 

Output : Arriving at : Jan 14 2014 04:33 PM</code></pre><p>可以看到，当前时间是用给定的”MMM dd yyyy hh:mm a”模式来表示的，它包含了三个字母表示的月份以及用AM及PM来表示的时间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://leilei666.github.io/my-blog/2019/08/16/Java-8新的时间日期库的20个使用实例/" data-id="ck3jwi95j000gz4w1dqsjwjq4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/my-blog/page/2/">2</a><a class="extend next" rel="next" href="/my-blog/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blog/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/my-blog/2019/11/29/springboot定时任务执行/">springboot定时任务执行</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/10/18/Freemarker的基本语法及入门基础/">Freemarker的基本语法及入门基础</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/10/12/java原子类及内部原理/">java原子类及内部原理</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/09/27/git命令/">git命令</a>
          </li>
        
          <li>
            <a href="/my-blog/2019/09/20/java开发必会的linux命令/">java开发必会的linux命令</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/my-blog/" class="mobile-nav-link">Home</a>
  
    <a href="/my-blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/my-blog/fancybox/jquery.fancybox.css">
  <script src="/my-blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/my-blog/js/script.js"></script>



  </div>
</body>
</html>